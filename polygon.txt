{
	"polygon": {
		"prefix": "polygon",
		"body": [
		  "struct point",
		  "{",
		  "    double x, y;",
		  "    point() { x = y = 0.0; }",
		  "    point(double _x, double _y) : x(_x), y(_y) {}",
		  "    bool operator==(point other) const",
		  "    {",
		  "        return (fabs(x - other.x) < EPS && (fabs(y - other.y) < EPS));",
		  "    }",
		  "    bool operator < (const point &p) const{",
		  "        if(x!=p.x) return x<p.x;",
		  "        return y<p.y;",
		  "    }",
		  "};",
		  "",
		  "struct vec",
		  "{",
		  "    double x, y;",
		  "    vec(double _x, double _y) : x(_x), y(_y) {}",
		  "};",
		  "",
		  "vec toVec(point a, point b)",
		  "{",
		  "    return vec(b.x - a.x, b.y - a.y);",
		  "}",
		  "",
		  "double dist(point p1, point p2)",
		  "{",
		  "    return hypot(p1.x - p2.x, p1.y - p2.y);",
		  "}",
		  "",
		  "double perimeter(const vector<point> &P)",
		  "{",
		  "    double result = 0.0;",
		  "    for (int i = 0; i < (int)P.size() - 1; i++) // remember that P[0] = P[n-1]",
		  "        result += dist(P[i], P[i + 1]);",
		  "    return result;",
		  "}",
		  "",
		  "// returns the area, which is half the determinant",
		  "double area(const vector<point> &P)",
		  "{",
		  "    double result = 0.0, x1, y1, x2, y2;",
		  "    for (int i = 0; i < (int)P.size() - 1; i++)",
		  "    {",
		  "        x1 = P[i].x;",
		  "        x2 = P[i + 1].x;",
		  "        y1 = P[i].y;",
		  "        y2 = P[i + 1].y;",
		  "        result += (x1 * y2 - x2 * y1);",
		  "    }",
		  "    return fabs(result) / 2.0;",
		  "}",
		  "",
		  "double dot(vec a, vec b) { return (a.x * b.x + a.y * b.y); }",
		  "",
		  "double norm_sq(vec v) { return v.x * v.x + v.y * v.y; }",
		  "",
		  "double angle(point a, point o, point b)",
		  "{ // returns angle aob in rad",
		  "    vec oa = toVec(o, a), ob = toVec(o, b);",
		  "    return acos(dot(oa, ob) / sqrt(norm_sq(oa) * norm_sq(ob)));",
		  "}",
		  "",
		  "double cross(vec a, vec b) { return a.x * b.y - a.y * b.x; }",
		  "",
		  "bool ccw(point p, point q, point r)",
		  "{",
		  "    return cross(toVec(p, q), toVec(p, r)) > 0;",
		  "}",
		  "",
		  "bool collinear(point p, point q, point r)",
		  "{",
		  "    return fabs(cross(toVec(p, q), toVec(p, r))) < EPS;",
		  "}",
		  "",
		  "// returns true if we always make the same turn while examining",
		  "// all the edges of the polygon one by one",
		  "bool isConvex(const vector<point> &P)",
		  "{",
		  "    int sz = (int)P.size();",
		  "    if (sz <= 3)",
		  "        return false;                    // a point/sz=2 or a line/sz=3 is not convex",
		  "    bool isLeft = ccw(P[0], P[1], P[2]); // remember one result",
		  "    for (int i = 1; i < sz - 1; i++)     // then compare with the others",
		  "        if (ccw(P[i], P[i + 1], P[(i + 2) == sz ? 1 : i + 2]) != isLeft)",
		  "            return false; // different sign -> this polygon is concave",
		  "    return true;",
		  "} // this polygon is convex",
		  "",

		  "bool onSeg(point a, point b, point p)",
		  "{",
		  "    if (min(a.x, b.x) - EPS <= p.x && p.x <= max(a.x, b.x) + EPS &&",
		  "        min(a.y, b.y) - EPS <= p.y && p.y <= max(a.y, b.x) + EPS &&",
		  "        collinear(a, b, p))",
		  "        return true;",
		  "    return false;",
		  "}",

		  "// returns true if point p is in either convex/concave polygon P",
		  "bool inPolygon(point q, vector<point> &p)",
		  "{",
		  "    int i, j, k = 0, n = p.size();",
		  "    for (i = 0, j = n - 1; i < n; j = i++)",
		  "    {",
		  "        if (p[i].y > q.y != p[j].y > q.y &&",
		  "            q.x < (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y) + p[i].x)",
		  "            k++;",
		  "        if (onSeg(p[i], p[j], q))",
		  "            return 1;",
		  "    }",
		  "    return k & 1;",
		  "}",
		  "",
		  "// line segment p-q intersect with line A-B.",
		  "point lineIntersectSeg(point p, point q, point A, point B)",
		  "{",
		  "    double a = B.y - A.y;",
		  "    double b = A.x - B.x;",
		  "    double c = B.x * A.y - A.x * B.y;",
		  "    double u = fabs(a * p.x + b * p.y + c);",
		  "    double v = fabs(a * q.x + b * q.y + c);",
		  "    return point((p.x * v + q.x * u) / (u + v), (p.y * v + q.y * u) / (u + v));",
		  "}",
		  "",
		  "// cuts polygon Q along the line formed by point a -> point b",
		  "vector<point> cutPolygon(point a, point b, const vector<point> &Q)",
		  "{",
		  "    vector<point> P;",
		  "    for (int i = 0; i < (int)Q.size(); i++)",
		  "    {",
		  "        double left1 = cross(toVec(a, b), toVec(a, Q[i])), left2 = 0;",
		  "        if (i != (int)Q.size() - 1)",
		  "            left2 = cross(toVec(a, b), toVec(a, Q[i + 1]));",
		  "        if (left1 > -EPS)",
		  "            P.push_back(Q[i]);    // Q[i] is on the left of ab",
		  "        if (left1 * left2 < -EPS) // edge (Q[i], Q[i+1]) crosses line ab",
		  "            P.push_back(lineIntersectSeg(Q[i], Q[i + 1], a, b));",
		  "    }",
		  "    if (!P.empty() && !(P.back() == P.front()))",
		  "        P.push_back(P.front()); // make P's first point = P's last point",
		  "    return P;",
		  "}",
		  "",
		  "void ConvexHull_MonotoneChain(vector<point> &P, vector<point> &H)",
		  "{",
		  "",
		  "    sort(P.begin(), P.end());",
		  "    H.resize(P.size() + 1);",
		  "    int n = P.size(), k = 0;",
		  "",
		  "    for (int i = 0; i < n; i++)",
		  "    {",
		  "        while (k >= 2 && !ccw(H[k - 2], H[k - 1], P[i]))",
		  "            k--;",
		  "        H[k++] = P[i];",
		  "    }",
		  "",
		  "    for (int i = n - 2, t = k; i >= 0; i--)",
		  "    {",
		  "        while (k > t && !ccw(H[k - 2], H[k - 1], P[i]))",
		  "            k--;",
		  "        H[k++] = P[i];",
		  "    }",
		  "    H.resize(k);",
		  "}",
		  ""
		],
		"description": "polygon"
	  }
}